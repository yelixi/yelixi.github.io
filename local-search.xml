<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leet-code</title>
    <link href="/2022/06/19/leet-code-99/"/>
    <url>/2022/06/19/leet-code-99/</url>
    
    <content type="html"><![CDATA[<h2 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a>99. 恢复二叉搜索树</h2><p>难度 <font color=#FFA119>中等</font></p><hr><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的<strong>恰好</strong>两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树 。</em></p><p><strong>示例 1：</strong><br><img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,3,null,null,2]<br>输出：[3,1,null,null,2]<br>解释：3 不能是<span class="hljs-number"> 1 </span>的左孩子，因为<span class="hljs-number"> 3 </span>&gt;<span class="hljs-number"> 1 </span>。交换<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>使二叉搜索树有效。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [3,1,4,null,null,2]<br>输出：[2,1,4,null,null,3]<br>解释：2 不能在<span class="hljs-number"> 3 </span>的右子树中，因为<span class="hljs-number"> 2 </span>&lt;<span class="hljs-number"> 3 </span>。交换<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 3 </span>使二叉搜索树有效。<br></code></pre></td></tr></table></figure><hr><h3 id="个人题解"><a href="#个人题解" class="headerlink" title="个人题解"></a>个人题解</h3><p>由于是搜索二叉树，中序遍历的结果是一个单调不减的数组。因此我们对给定的二叉树进行中序遍历，用链表储存遍历结果，再对链表中所有元素进行遍历，找到不符合单调不减的两个数记录为<code>i</code>，<code>j</code>。之后再次遍历二叉树，对这两个节点进行交换，由于不能改变结构，因此只需要交换<code>value</code><br><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        mid(root);<br>        <span class="hljs-type">int</span>[] n = findTwoSwapped();<br>        recover(root,<span class="hljs-number">2</span>,n[<span class="hljs-number">0</span>],n[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mid</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        mid(node.left);<br>        nums.add(node.val);<br>        mid(node.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findTwoSwapped() &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, index2 = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums.get(i + <span class="hljs-number">1</span>) &lt; nums.get(i)) &#123;<br>                index2 = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (index1 == -<span class="hljs-number">1</span>) &#123;<br>                    index1 = i;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums.get(index1), y = nums.get(index2);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recover</span><span class="hljs-params">(TreeNode node,<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node.val==num1||node.val==num2)&#123;<br>            node.val = node.val == num1?num2:num1;<br>            <span class="hljs-keyword">if</span>(--num==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        recover(node.left,num,num1,num2);<br>        recover(node.right,num,num1,num2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(N)<br>空间复杂度O(N)</p><hr><p>我个人的解法是通过链表来查询出错的两个节点，但很显然，我们可以在第一次遍历的时候就能查出错误节点，但本人能力有限，因此查看题解，发现有更优解：<br><strong>方法二：隐式中序遍历</strong><br>具体来说，由于我们只关心中序遍历的值序列中每个相邻的位置的大小关系是否满足条件，且错误交换后最多两个位置不满足条件，因此在中序遍历的过程我们只需要维护当前中序遍历到的最后一个节点 \textit{pred}pred，然后在遍历到下一个节点的时候，看两个节点的值是否满足前者小于后者即可，如果不满足说明找到了一个交换的节点，且在找到两次以后就可以终止遍历。</p><p>这样我们就可以在中序遍历中直接找到被错误交换的两个节点 xx 和 yy，不用显式建立 \textit{nums}nums 数组。</p><p>中序遍历的实现有迭代和递归两种等价的写法，在本方法中提供迭代实现的写法。使用迭代实现中序遍历需要手动维护栈。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> recoverTree(TreeNode root) &#123;<br>        Deque<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> stack <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayDeque<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span>();<br>        TreeNode x <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, y <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, pred <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-operator">!</span>stack.isEmpty() <span class="hljs-operator">||</span> root <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">while</span> (root <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>) &#123;<br>                stack.push(root);<br>                root <span class="hljs-operator">=</span> root.left;<br>            &#125;<br>            root <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span> (pred <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> root.<span class="hljs-keyword">val</span> <span class="hljs-operator">&lt;</span> pred.<span class="hljs-keyword">val</span>) &#123;<br>                y <span class="hljs-operator">=</span> root;<br>                <span class="hljs-keyword">if</span> (x <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>) &#123;<br>                    x <span class="hljs-operator">=</span> pred;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    break;<br>                &#125;<br>            &#125;<br>            pred <span class="hljs-operator">=</span> root;<br>            root <span class="hljs-operator">=</span> root.right;<br>        &#125;<br><br>        swap(x, y);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> swap(TreeNode x, TreeNode y) &#123;<br>        int tmp <span class="hljs-operator">=</span> x.<span class="hljs-keyword">val</span>;<br>        x.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> y.<span class="hljs-keyword">val</span>;<br>        y.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> tmp;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：最坏情况下（即待交换节点为二叉搜索树最右侧的叶子节点）我们需要遍历整棵树，时间复杂度为 O(N)O(N)，其中 NN 为二叉搜索树的节点个数。<br>空间复杂度：O(H)O(H)，其中 HH 为二叉搜索树的高度。中序遍历的时候栈的深度取决于二叉搜索树的高度。</p><p><strong>方法三：Morris 中序遍历<br>思路与算法</strong></p><p>方法二中我们不再显示的用数组存储中序遍历的值序列，但是我们会发现我们仍需要 O(H)O(H) 的栈空间，无法满足题目的进阶要求，那么该怎么办呢？这里向大家介绍一种不同于平常递归或迭代的遍历二叉树的方法：<strong>Morris 遍历算法</strong>，该算法能将非递归的中序遍历空间复杂度降为 O(1)O(1)。</p><p><strong>Morris 遍历算法</strong>整体步骤如下（假设当前遍历到的节点为 xx）：</p><ol><li>如果<code>x</code>无左孩子，则访问 <code>x</code> 的右孩子，即 <code>x = x.x.right</code>。</li><li>如果 <code>x</code> 有左孩子，则找到 <code>x</code> 左子树上最右的节点（<strong>即左子树中序遍历的最后一个节点，<code>x</code> 在中序遍历中的前驱节点</strong>），我们记为 <code>predecessor</code>。根据 <code>predecessor</code> 的右孩子是否为空，进行如下操作。<ul><li>如果<code>predecessor</code> 的右孩子为空，则将其右孩子指向 <code>x</code>，然后访问 <code>x</code> 的左孩子，即 <code>x = x.left</code>。</li><li>如果 <code>predecessor</code> 的右孩子不为空，则此时其右孩子指向 <code>x</code>，说明我们已经遍历完 <code>x</code> 的左子树，我们将 <code>predecessor</code> 的右孩子置空，然后访问 <code>x</code> 的右孩子，即 <code>x = x.right</code>。</li></ul></li><li>重复上述操作，直至访问完整棵树。</li></ol><hr><p>其实整个过程我们就多做一步：将当前节点左子树中最右边的节点指向它，这样在左子树遍历完成后我们通过这个指向走回了 xx，且能再通过这个知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p><p>了解完这个算法以后，其他地方与方法二并无不同，我们同样也是维护一个 \textit{pred}pred 变量去比较即可，具体实现可以看下面的代码，这里不再赘述。</p><p><strong>代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, y = <span class="hljs-literal">null</span>, pred = <span class="hljs-literal">null</span>, predecessor = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span><br>                predecessor = root.left;<br>                <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-literal">null</span> &amp;&amp; predecessor.right != root) &#123;<br>                    predecessor = predecessor.right;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span><br>                <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-literal">null</span>) &#123;<br>                    predecessor.right = root;<br>                    root = root.left;<br>                &#125;<br>                <span class="hljs-comment">// 说明左子树已经访问完了，我们需要断开链接</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt; pred.val) &#123;<br>                        y = root;<br>                        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>                            x = pred;<br>                        &#125;<br>                    &#125;<br>                    pred = root;<br><br>                    predecessor.right = <span class="hljs-literal">null</span>;<br>                    root = root.right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有左孩子，则直接访问右孩子</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt; pred.val) &#123;<br>                    y = root;<br>                    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>                        x = pred;<br>                    &#125;<br>                &#125;<br>                pred = root;<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        swap(x, y);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(TreeNode x, TreeNode y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> x.val;<br>        x.val = y.val;<br>        y.val = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)O(N)，其中 NN 为二叉搜索树的高度。Morris 遍历中每个节点会被访问两次，因此总时间复杂度为 O(2N)=O(N)O(2N)=O(N)。</li><li>空间复杂度：O(1)O(1)。</li></ul><p>转载来自<a href="https://leetcode.cn/problems/recover-binary-search-tree/solution/hui-fu-er-cha-sou-suo-shu-by-leetcode-solution/">恢复二叉搜索树</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>leet-code,二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2022/06/18/frist-blog/"/>
    <url>/2022/06/18/frist-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="这是我的第一篇博客，也就随便写写吧，就当是markdown语法的训练吧"><a href="#这是我的第一篇博客，也就随便写写吧，就当是markdown语法的训练吧" class="headerlink" title="这是我的第一篇博客，也就随便写写吧，就当是markdown语法的训练吧"></a>这是我的第一篇博客，也就随便写写吧，就当是markdown语法的训练吧</h1><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><p>Markdown 标题有两种格式。</p><h3 id="1、使用-和-标记一级和二级标题"><a href="#1、使用-和-标记一级和二级标题" class="headerlink" title="1、使用 = 和 - 标记一级和二级标题"></a>1、使用 = 和 - 标记一级和二级标题</h3><p>= 和 - 标记语法格式如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">我是一级标题</span><br><span class="hljs-section">==========</span><br><span class="hljs-section">我是二级标题</span><br><span class="hljs-section">----------</span><br></code></pre></td></tr></table></figure><p>效果：</p><h1 id="我是一级标题"><a href="#我是一级标题" class="headerlink" title="我是一级标题"></a>我是一级标题</h1><h2 id="我是二级标题"><a href="#我是二级标题" class="headerlink" title="我是二级标题"></a>我是二级标题</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，<em><strong>段落的换行是使用两个以上空格加上回车。</strong></em><br><img src="https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg"><br>当然也可以在段落后面使用一个空行来表示重新开始一个段落。<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg"></p><hr><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-emphasis">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-emphasis">___粗斜体文本__</span>_<br></code></pre></td></tr></table></figure><p>显示效果如下所示：</p><hr><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/md3.gif"></p><hr><h2 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h2><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号(<code>*</code>)、加号(<code>+</code>)或是减号(<code>-</code>)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 第一项<br><span class="hljs-bullet">*</span> 第二项<br><span class="hljs-bullet">*</span> 第三项<br><br><span class="hljs-bullet">+</span> 第一项<br><span class="hljs-bullet">+</span> 第二项<br><span class="hljs-bullet">+</span> 第三项<br><br><br><span class="hljs-bullet">-</span> 第一项<br><span class="hljs-bullet">-</span> 第二项<br><span class="hljs-bullet">-</span> 第三项<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg"><br>有序列表使用数字并加上*** .*** 号来表示，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项<br><span class="hljs-bullet">2.</span> 第二项<br><span class="hljs-bullet">3.</span> 第三项<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/560384BB-2B00-41D5-ACF2-18972F7F2775.jpg"></p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第一项：<br><span class="hljs-bullet">    -</span> 第一项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第一项嵌套的第二个元素<br><span class="hljs-bullet">2.</span> 第二项：<br><span class="hljs-bullet">    -</span> 第二项嵌套的第一个元素<br><span class="hljs-bullet">    -</span> 第二项嵌套的第二个元素<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/8ED795DA-F124-4E70-BA71-57CD9CF958A4.jpg"></p><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><p>Markdown 区块引用是在段落开头使用 <code>&gt;</code> 符号 ，然后后面紧跟一个空格符号：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">区块引用</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">菜鸟教程</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">学的不仅是技术更是梦想</span><br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/DFE1124E-BC38-4C12-B7AC-053E560D4C9C.jpg"><br>另外区块是可以嵌套的，一个<code> &gt;</code> 符号是最外层，两个 <code>&gt;</code> 符号是第一层嵌套，以此类推：<br>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/AA0A4A6A-33A7-48C7-971F-73FFC8FE85B0.jpg"></p><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表实例如下：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">区块中使用列表</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">1.</span> 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">2.</span> 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第一项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第二项</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">+ 第三项</span><br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/E3BF6399-6483-4C7A-8502-AE75E8D66C96.jpg"><br>列表中使用区块<br>如果要在列表项目内放进区块，那么就需要在 <code>&gt;</code> 前添加四个空格的缩进。</p><p>列表中使用区块实例如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>第一项<br><span class="hljs-code">    &gt; 菜鸟教程</span><br><span class="hljs-code">    &gt; 学的不仅是技术更是梦想</span><br><span class="hljs-bullet">* </span>第二项<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/1B894FB4-53AC-4E2D-BA30-F4AE4DFA8B97.jpg">  </p><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`printf()` 函数<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg">   </p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p><p>实例如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/55EDFE05-5F27-458E-AFE0-7B96685C9603.jpg"><br>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/6DC89E5C-B41A-4938-97D8-D7D06B879F91.jpg"><br>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">```<span class="language-javascript">javascript</span><br><span class="language-javascript">$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ready</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span>```<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/88F52386-2F98-4D7E-8935-E43BECA6D868.jpg">  </p><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>链接使用方法如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[链接名称]</span>(链接地址)<br><br>或者<br><br>&lt;链接地址&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">这是一个链接 <span class="hljs-selector-attr">[菜鸟教程]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.runoob.com)</span><br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/49E6CB42-F780-4DA6-8290-DC757B51FB9A.jpg"><br>直接使用链接地址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;https:<span class="hljs-regexp">//</span>www.runoob.com&gt;<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/9BFF60A1-DD71-4B63-987B-4665B31C7787.jpg"></p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less">这个链接用 <span class="hljs-number">1</span> 作为网址变量 <span class="hljs-selector-attr">[Google]</span><span class="hljs-selector-attr">[1]</span><br>这个链接用 <span class="hljs-selector-tag">runoob</span> 作为网址变量 <span class="hljs-selector-attr">[Runoob]</span><span class="hljs-selector-attr">[runoob]</span><br>然后在文档的结尾为变量赋值（网址）<br><br>  <span class="hljs-selector-attr">[1]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.google.com/</span><br>  <span class="hljs-selector-attr">[runoob]</span>: <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.runoob.com/</span><br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/EC3ED5D2-4F0D-492A-81B3-D485623D1A9E.jpg">  </p><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p>Markdown 图片语法格式如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[ 属性文本]</span>(图片地址)<br><br>!<span class="hljs-selector-attr">[ 属性文本]</span>(图片地址 &quot;可选标题&quot;)<br></code></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png)<br><br>![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png <span class="hljs-string">&quot;RUNOOB&quot;</span>)<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg"><br>当然，你也可以像网址那样对图片网址使用变量:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">这个链接用 <span class="hljs-number">1</span> 作为网址变量 [RUNOOB][<span class="hljs-number">1</span>].<br>然后在文档的结尾为变量赋值（网址）<br><br>[<span class="hljs-number">1</span>]: http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/75AA6EBF-CC57-44A6-A585-5EE3DD94E42A.jpg"><br>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/55F2A67D-F4BD-4960-AC55-DC690A415878.jpg">  </p><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</p><p>语法格式如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">  表头   </span>|<span class="hljs-string"> 表头  </span>|<br>|<span class="hljs-string">  ----  </span>|<span class="hljs-string"> ----  </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><p>以上代码显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg"><br>对齐方式</p><p>我们可以设置表格的对齐方式：</p><ul><li><code>-:</code> 设置内容和标题栏居右对齐。</li><li><code>:-</code> 设置内容和标题栏居左对齐。</li><li><code>:-:</code> 设置内容和标题栏居中对齐。<br>实例如下：</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><p>以上代码显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
